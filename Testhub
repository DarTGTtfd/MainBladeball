local Stats = game:GetService("Stats")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Nurysium_Util = loadstring(game:HttpGet("https://raw.githubusercontent.com/flezzpe/Nurysium/main/nurysium_helper.lua"))()
local libary = loadstring(game:HttpGet("https://pastebin.com/raw/0yMKk86F",true))()


local function getTrainingBall()
	for index, ball in workspace:WaitForChild("TrainingBalls"):GetChildren() do
		if ball:IsA("BasePart") and ball:GetAttribute("realBall") then
			return ball
		end
	end
end

local local_player = Players.LocalPlayer
local camera = workspace.CurrentCamera


local originalParryRemote
local originalResolveParryRemote 

local nurysium_dataa = nil
local hit_Sound = nil
local closest_Entity = nil

local auto_parry = false
local auto_curve = false
local auto_spam = false
local training_mode = false
local anti_curve_spam_Enabled = false
local visualize_Enabled = false
local hit_sound_Enabled = false
local hit_effect_Enabled = false
local night_mode_Enabled = false
local trail_Enabled = false
local ball_trial_Enabled = false
local self_effect_Enabled = false
local kill_effect_Enabled = false
local shaders_effect_Enabled = false
local ai_Enabled = false
local auto_win = false
local tp_hit = false
local spectate_Enabled = false
local skibidi = true
local takentimestart = false




task.wait(0.5)

local window = libary:init({
	name = "Baka Hub"
})

local Tab1 = window:Tab({
	name = "Combat"
})

local Tab2 = window:Tab({
	name = "Visual"
})

local Tab3 = window:Tab({
	name = "Settings"
})
local Services = {game:GetService("AdService"),game:GetService("SocialService")}


function initializate(dataaFolder_name)
	nurysium_dataa = Instance.new("Folder", game:GetService("CoreGui"))
	nurysium_dataa.Name = dataaFolder_name
	hit_Sound = Instance.new("Sound", nurysium_dataa)
	hit_Sound.SoundId = "rbxassetid://8632670510"
	hit_Sound.Volume = 5
end

local function get_closest_entity(Object)
	task.spawn(function()
		local closest
		local max_distance = math.huge
		for index, entity in workspace.Alive:GetChildren() do
			if entity.Name ~= Players.LocalPlayer.Name then
				local distance = (Object.Position - entity.HumanoidRootPart.Position).Magnitude
				if distance < max_distance then
					closest_Entity = entity
					max_distance = distance
				end
			end
		end
		return closest_Entity
	end)
end

function resolve_parry_Remote()
	for _, value in pairs(Services) do
		local temp_remote = value:FindFirstChildOfClass('RemoteEvent')
		if not temp_remote then
			continue
		end
		if not temp_remote.Name:find('\n') then
			continue
		end
		originalParryRemote = temp_remote
	end
end

resolve_parry_Remote()

function walk_to(position)
	local_player.Character.Humanoid:MoveTo(position)
end
local function get_center()
	for _, object in workspace.Map:GetDescendants() do
		if object.Name == 'BALLSPAWN' then
			return object
		end
	end
end

local data = {
	canParry = true,
	modeParry = nil,
	is_Spamming = false,
	parry_Range = 30,
	spam_Range = 10,  
	hit_Count = 0,
	target_Count = 0,
	hit_Time = tick(),
	ball_Warping = tick(),
	is_ball_Warping = false,
	last_target = nil,
	is_target = false,
	taken_time = 1,
	aero_taken_times = 0,
	not_target_time = tick(),
	distance_player_to_ball = 0,
	aero_find = false,
	can_spam = true,
	last_angle_degrees = 0,
	last_ball_position = Vector3.new(0,0,0),
	is_curving = false,
	telesink_start_time = nil,
	is_telesinking = false,
	pull_start_time = nil,
	is_pulled = false,
	last_ball_speed = 0,
	spam_delay = 0,
	last_check_time = 0,
}

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
	if takentimestart then
		data.taken_time = tick() - data.hit_Time
	end

	if hit_sound_Enabled then
		hit_Sound:Play()
	end
	if hit_effect_Enabled then
		local hit_effect = game:GetObjects("rbxassetid://17407244385")[1]
		hit_effect.Parent = Nurysium_Util.getBall()
		hit_effect:Emit(3)
		task.delay(5, function()
			hit_effect:Destroy()
		end)
	end
end)


workspace:WaitForChild("Balls").ChildRemoved:Connect(function(child)
	data.target_Count = 0
	data.taken_time = 1
	data.hit_Count = 0
	data.is_ball_Warping = false
	data.is_Spamming = false
	data.can_parry = true
	data.last_target = nil
end)



function ManualSpam()
	loadstring(game:HttpGet("https://pastebin.com/raw/KNgpQxtv"))()
end


local function clamp(value, min, max)
	return math.max(min, math.min(max, value))
end



task.defer(function()
	local self = Nurysium_Util.getBall()
	local Visualize = Instance.new("Part",workspace)
	Visualize.Color = Color3.new(0, 1, 0)
	Visualize.Material = Enum.Material.ForceField
	Visualize.Transparency = 0.5
	Visualize.Anchored = true
	Visualize.CanCollide = false
	Visualize.CastShadow = false
	Visualize.Shape = Enum.PartType.Ball
	Visualize.Size = Vector3.new(30,30,30)

	local Highlight = Instance.new("Highlight")
	Highlight.Parent = Visualize
	Highlight.Enabled = true
	Highlight.FillTransparency = 0
	Highlight.OutlineColor = Color3.new(1, 1, 1)

	RunService.RenderStepped:Connect(function()
		if visualize_Enabled and local_player then
			Visualize.Transparency = 0
			Visualize.Material = Enum.Material.ForceField
			Visualize.Size = Vector3.new(data.parry_Range,data.parry_Range,data.parry_Range)
			Visualize.CFrame = CFrame.new(local_player.Character.PrimaryPart.Position)
		else
			Visualize.Material = Enum.Material.ForceField
			Visualize.Transparency = 1
		end	
	end)
end)

task.defer(function()
	local self = Nurysium_Util.getBall()
	local Visualize = Instance.new("Part",workspace)
	Visualize.Color = Color3.new(1, 0, 0)
	Visualize.Material = Enum.Material.ForceField
	Visualize.Transparency = 0.5
	Visualize.Anchored = true
	Visualize.CanCollide = false
	Visualize.CastShadow = false
	Visualize.Shape = Enum.PartType.Ball
	Visualize.Size = Vector3.new(30,30,30)

	local Highlight = Instance.new("Highlight")
	Highlight.Parent = Visualize
	Highlight.Enabled = true
	Highlight.FillTransparency = 0
	Highlight.OutlineColor = Color3.new(1, 1, 1)

	RunService.RenderStepped:Connect(function()
		if visualize_Enabled and local_player then
			Visualize.Transparency = 0
			Visualize.Material = Enum.Material.ForceField
			Visualize.Size = Vector3.new(data.spam_Range,data.spam_Range,data.spam_Range)
			Visualize.CFrame = CFrame.new(local_player.Character.PrimaryPart.Position)
		else
			Visualize.Material = Enum.Material.ForceField
			Visualize.Transparency = 1
		end	
	end)
end)

print("Baka Hub XD LEST GOOOO")

task.defer(function()
	game:GetService("RunService").Heartbeat:Connect(function()
		if not local_player.Character then
			return
		end
		if trail_Enabled then
			local trail = game:GetObjects("rbxassetid://17483658369")[1]
			trail.Name = "nurysium_fx"
			if local_player.Character.PrimaryPart:FindFirstChild("nurysium_fx") then
				return
			end
			local Attachment0 = Instance.new("Attachment", local_player.Character.PrimaryPart)
			local Attachment1 = Instance.new("Attachment", local_player.Character.PrimaryPart)
			Attachment0.Position = Vector3.new(0, -2.411, 0)
			Attachment1.Position = Vector3.new(0, 2.504, 0)
			trail.Parent = local_player.Character.PrimaryPart
			trail.Attachment0 = Attachment0
			trail.Attachment1 = Attachment1
		else
			if local_player.Character.PrimaryPart:WaitForChild("nurysium_fx", 9e9) then
				local_player.Character.PrimaryPart["nurysium_fx"]:Destroy()
			end
		end
	end)
end)

task.defer(function()
	RunService.RenderStepped:Connect(function()
		if spectate_Enabled then
			local self = Nurysium_Util.getBall()
			if not self then
				return
			end
			workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(CFrame.new(workspace.CurrentCamera.CFrame.Position, self.Position), 1.5)
		end
	end)
end)

task.defer(function()
	while task.wait(1) do
		if night_mode_Enabled then
			game:GetService("TweenService"):Create(game:GetService("Lighting"), TweenInfo.new(3), {ClockTime = 3.9}):Play()
		else
			game:GetService("TweenService"):Create(game:GetService("Lighting"), TweenInfo.new(3), {ClockTime = 13.5}):Play()
		end
	end
end)

task.defer(function()
	local ball = nil

	-- ŕ¸ŕ¸ąŕ¸ŕ¸ŕšŕ¸ŕ¸ąŕ¸ŕ¸Şŕ¸łŕ¸Ťŕ¸Łŕ¸ąŕ¸ŕ¸ŕ¸˛ŕ¸Łŕ¸Şŕ¸Łŕšŕ¸˛ŕ¸ŕ¸Ťŕ¸Łŕ¸ˇŕ¸­ŕ¸­ŕ¸ąŕ¸ŕšŕ¸ŕ¸ Trail
	local function createOrUpdataeTrail()
		local Trail = ball:FindFirstChild("Trail")
		if not Trail then
			Trail = Instance.new("Trail")
			Trail.Name = "Trail"
			Trail.FaceCamera = true
			Trail.Parent = ball
		end

		local At1 = ball:FindFirstChild("at1")
		local At2 = ball:FindFirstChild("at2")

		if At1 and At2 then
			Trail.Attachment0 = At1
			Trail.Attachment1 = At2

			Trail.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.new(1.00, 0.00, 0.02)),
				ColorSequenceKeypoint.new(0.14, Color3.new(0.98, 1.00, 0.00)),
				ColorSequenceKeypoint.new(0.30, Color3.new(0.07, 1.00, 0.00)),
				ColorSequenceKeypoint.new(0.48, Color3.new(0.00, 0.98, 1.00)),
				ColorSequenceKeypoint.new(0.69, Color3.new(0.03, 0.00, 1.00)),
				ColorSequenceKeypoint.new(0.88, Color3.new(1.00, 0.00, 0.98)),
				ColorSequenceKeypoint.new(1.00, Color3.new(1.00, 0.00, 0.02))
			}

			Trail.WidthScale = NumberSequence.new{
				NumberSequenceKeypoint.new(0.00, .5, 0.00),
				NumberSequenceKeypoint.new(1.00, 0.00, 0.00)
			}

			Trail.Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0.00, 0.00, 0.00),
				NumberSequenceKeypoint.new(1.00, 1.00, 0.00)
			}

			Trail.Enabled = true
		end
	end

	-- ŕ¸ŕ¸ąŕ¸ŕ¸ŕšŕ¸ŕ¸ąŕ¸ŕ¸Şŕ¸łŕ¸Ťŕ¸Łŕ¸ąŕ¸ŕ¸ŕ¸˛ŕ¸Łŕšŕ¸ŕ¸´ŕ¸ Trail ŕšŕ¸Ľŕ¸°ŕ¸ŕ¸´ŕ¸ ff
	local function enableTrailAndDisableFF()
		local Trail = ball:FindFirstChild("Trail")
		if not Trail then
			createOrUpdataeTrail()
			Trail = ball:FindFirstChild("Trail")
		end

		if Trail then
			Trail.Enabled = true
		end

		local ff = ball:FindFirstChild("ff")
		if ff then
			ff.Enabled = false
		end
	end

	-- ŕ¸ŕ¸ąŕ¸ŕ¸ŕšŕ¸ŕ¸ąŕ¸ŕ¸Şŕ¸łŕ¸Ťŕ¸Łŕ¸ąŕ¸ŕ¸ŕ¸˛ŕ¸Łŕ¸ŕ¸´ŕ¸ Trail ŕšŕ¸Ľŕ¸°ŕšŕ¸ŕ¸´ŕ¸ ff
	local function disableTrailAndEnableFF()
		local Trail = ball:FindFirstChild("Trail")
		if Trail then
			Trail:Destroy()
		end

		local ff = ball:FindFirstChild("ff")
		if ff then
			ff.Enabled = true
		end
	end

	-- ŕšŕ¸ŕš RenderStepped ŕšŕ¸ŕ¸ˇŕšŕ¸­ŕ¸Łŕ¸ąŕ¸ŕ¸ŕ¸­ŕ¸Ľŕšŕ¸ŕšŕ¸ŕšŕ¸Ľŕ¸°ŕšŕ¸ŕ¸Łŕ¸Ą
	RunService.RenderStepped:Connect(function()
		ball = Nurysium_Util.getBall()

		if ball then
			if ball_trial_Enabled then
				enableTrailAndDisableFF()
			else
				disableTrailAndEnableFF()
			end
		end
	end)
end)
function getClosestEntityToMouse()
	local closest = nil
	local shortestDistance = math.huge
	local mouse = game.Players.LocalPlayer:GetMouse()

	-- Ensure workspace.Alive exists
	if not workspace:FindFirstChild("Alive") then
		return nil
	end

	-- Loop through all entities
	for _, entity in pairs(workspace.Alive:GetChildren()) do
		if entity:IsA("Model") then
			local humanoidRootPart = entity:FindFirstChild("HumanoidRootPart")
			if humanoidRootPart then
				-- Convert world position to screen position
				local screenPoint = camera:WorldToViewportPoint(humanoidRootPart.Position)
				local distanceToMouse = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude

				-- Check if this is the closest entity so far
				if distanceToMouse < shortestDistance then
					closest = entity
					shortestDistance = distanceToMouse
				end
			else

			end
		else

		end
	end

	-- If no closest entity is found, warn the user
	if not closest then

	else

	end

	return closest
end




task.defer(function()
	local runService = game:GetService("RunService")
	local Players = game:GetService("Players")

	local function avoidWalls(startPos, targetPos)
		local direction = (targetPos - startPos).Unit
		local ray = Ray.new(startPos, direction * 10)
		local hit, hitPosition = workspace:FindPartOnRay(ray, local_player.Character)

		if hit then
			-- Wall detected, adjust path
			local adjustedDir = (targetPos - hitPosition).Unit + Vector3.new(0, 0, 0.5) -- Simple adjustment
			return startPos + adjustedDir * 10
		end

		return targetPos
	end

	runService.Stepped:Connect(function()
		if not ai_Enabled or not workspace.Alive:FindFirstChild(local_player.Name) then
			return
		end

		local self = Nurysium_Util.getBall()
		if not self or not closest_Entity then
			return
		end

		local hrp = closest_Entity:FindFirstChild('HumanoidRootPart')
		if not hrp then
			walk_to(local_player.Character.HumanoidRootPart.Position + Vector3.new(math.sin(tick()) * math.random(35, 50), 0, math.cos(tick()) * math.random(35, 50)))
			return
		end

		local tickNow = tick()
		local tickMod = tickNow % 4
		local ball_Position = self.Position
		local ball_Distance = local_player:DistanceFromCharacter(ball_Position)
		local player_Position = local_player.Character.PrimaryPart.Position
		local target_Position = hrp.Position
		local target_Distance = local_player:DistanceFromCharacter(target_Position)
		local target_LookVector = hrp.CFrame.LookVector
		local resolved_Position = Vector3.zero

		local target_Humanoid = closest_Entity:FindFirstChildOfClass("Humanoid")
		if target_Humanoid and target_Humanoid:GetState() == Enum.HumanoidStateType.Jumping and local_player.Character.Humanoid.FloorMaterial ~= Enum.Material.Air then
			local_player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
		end

		if (ball_Position - player_Position):Dot(local_player.Character.PrimaryPart.CFrame.LookVector) < -0.2 and tickMod <= 2 then
			return
		end

		-- Maintain distance or get close depending on spamming state
		if data.is_Spamming then
			-- When spamming, move closer to the target
			if tickMod <= 2 then
				resolved_Position = target_Position + (player_Position - target_Position).Unit * 8
			else
				resolved_Position = target_Position - target_LookVector * (math.random(8.5, 13.5) + (ball_Distance / math.random(8, 20)))
			end
		else
			-- Avoid getting too close to other players when not spamming
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= local_player and workspace.Alive:FindFirstChild(player.Name) then
					local otherPlayerPos = player.Character and player.Character.PrimaryPart.Position
					if otherPlayerPos and (player_Position - otherPlayerPos).Magnitude < 10 then
						local avoidanceVector = (player_Position - otherPlayerPos).Unit * 15
						player_Position = player_Position + avoidanceVector
					end
				end
			end

			-- Regular pathfinding when not spamming
			if tickMod <= 2 then
				resolved_Position = target_Distance > 10 and target_Position + (player_Position - target_Position).Unit * 25
			else
				resolved_Position = target_Position - target_LookVector * (math.random(8.5, 13.5) + (ball_Distance / math.random(8, 20)))
			end
		end

		if (player_Position - target_Position).Magnitude < 8 then
			resolved_Position = target_Position + (player_Position - target_Position).Unit * 35
		end

		if ball_Distance < 8 then
			resolved_Position = player_Position + (player_Position - ball_Position).Unit * 10
		end

		-- Avoid walls before walking
		resolved_Position = avoidWalls(player_Position, resolved_Position)

		walk_to(resolved_Position + Vector3.new(math.sin(tickNow) * 10, 0, math.cos(tickNow) * 10))
	end)
end)



task.defer(function()
	RunService.Stepped:Connect(function()
		if auto_win and workspace.Alive:FindFirstChild(local_player.Name) then
			local self = Nurysium_Util.getBall()
			if not self then return end

			local player = local_player.Character
			local ball_Position = self.Position
			local ball_Distance = (player.HumanoidRootPart.Position - ball_Position).Magnitude


			local ping = game:GetService("Stats"):FindFirstChild("PerformanceStats"):FindFirstChild("Ping"):GetValue() or 0
			local adjusted_Distance = math.clamp(15 + (ping / 50), 15, 50)


			local angle = tick() * 2
			local offset = Vector3.new(math.cos(angle) * adjusted_Distance, math.sin(angle) * 5, math.sin(angle) * adjusted_Distance)
			local target_Position = ball_Position + offset


			player.HumanoidRootPart.CFrame = CFrame.new(target_Position, ball_Position)
		end
	end)
end)

task.defer(function()
	RunService.Heartbeat:Connect(function()
		local self = Nurysium_Util.getBall()
		if not self or not tp_hit then return end
		local player = local_player.Character
		local ball_Position = self.Position

		if tp_hit and self:GetAttribute('target') == local_player.Name and workspace.Alive:FindFirstChild(local_player.Name) then

			local safe_Distance = 10
			local direction = (ball_Position - player.HumanoidRootPart.Position).Unit
			local target_Position = ball_Position - direction * safe_Distance

			player.HumanoidRootPart.CFrame = CFrame.new(target_Position)
		end
	end)
end)
local closest_Entity_To_mouse = nil


task.defer(function()
	RunService.Heartbeat:Connect(function()
		closest_Entity_To_mouse = getClosestEntityToMouse()
	end)
end)




local Takentime = tick() - data.hit_Time

RunService.Heartbeat:Connect(function()
	Takentime = tick() - data.hit_Time
end)


Tab1:AddToggle({
	name = "Auto Parry (Set Mode In Settings)",
	callback = function(v)
		auto_parry = v

	end
})

local d = Tab3:AddDropdown({
	name = "Parry Mode (Select FIRST!!)",
	callback = function(v)
		data.modeParry = v
		print(v)

	end,
})

d:Add("Rage","Rage")
d:Add("Legit","Legit")

Tab1:AddToggle({
	name = "Auto Spam",
	callback = function(v)
		auto_spam = v

	end
})

Tab1:AddToggle({
	name = "Auto Curve",
	callback = function(v)
		auto_curve = v

	end
})

Tab1:AddToggle({
	name = "Auto Play",
	callback = function(v)
		ai_Enabled = v

	end
})











Tab1:AddToggle({
	name = "Follow Ball",
	callback = function(v)
		auto_win = v

	end
})

Tab1:AddToggle({
	name = "TP Hit",
	callback = function(v)
		tp_hit = v

	end
})
Tab1:AddToggle({
	name = "Training Mode",
	callback = function(v)
		training_mode = v

	end
})

Tab2:AddToggle({
	name = "Visualize",
	callback = function(v)
		visualize_Enabled = v

	end
})

Tab2:AddToggle({
	name = "Hit Sound",
	callback = function(v)
		hit_sound_Enabled = v

	end
})

Tab2:AddToggle({
	name = "Hit Effect",
	callback = function(v)
		hit_effect_Enabled = v

	end
})

Tab2:AddToggle({
	name = "Nightmode",
	callback = function(v)
		night_mode_Enabled = v

	end
})

Tab2:AddToggle({
	name = "Trail",
	callback = function(v)
		trail_Enabled = v

	end
})

Tab2:AddToggle({
	name = "Ball Trail",
	callback = function(v)
		ball_trial_Enabled = v

	end
})




task.spawn(function()
	RunService:BindToRenderStep("PreAutoSpam", Enum.RenderPriority.First.Value, function() --Auto Spam
		if not auto_spam or not workspace.Alive:FindFirstChild(local_player.Name) or training_mode or data.modeParry == nil then
			data.target_Count = 0
			data.hit_Count = 0
			data.is_Spamming = false
			data.last_target = nil
			return
		end    

		local waittime

		if data.modeParry == "Rage" then
			waittime = 0
		else
			waittime = 1
		end
		if closest_Entity then
			if workspace.Alive:FindFirstChild(closest_Entity.Name) then
				if data.is_Spamming then
					if workspace.Alive:FindFirstChild(local_player.Name) and data.can_spam and (local_player.Character.PrimaryPart.Position - closest_Entity.HumanoidRootPart.Position).Magnitude <= data.spam_Range  then
						task.spawn(function()
							repeat
								for v = 1,10 do
									if auto_curve then
										originalParryRemote:FireServer(
											0,
											CFrame.new(camera.CFrame.Position, Vector3.new(math.random(-1000, 1000), math.random(0, 1000), math.random(100, 1000))),
											{[closest_Entity_To_mouse.Name] = closest_Entity_To_mouse.HumanoidRootPart.Position},
											{closest_Entity_To_mouse.HumanoidRootPart.Position.X, closest_Entity_To_mouse.HumanoidRootPart.Position.Y},
											false
										)
									else
										local cf = camera.CFrame
										local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:GetComponents()
										originalParryRemote:FireServer(
											0,
											CFrame.new(x, y, z, R00, R01, R02, R
